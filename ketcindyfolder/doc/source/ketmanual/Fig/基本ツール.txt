title(org):=(  regional(x,y);  x=4.5;y=1.7;  rectangle=[org,org+[x,0],org+[x,y],org+[0,y]];  fillpoly(rectangle,color->[1,1,0],alpha->0.5);  drawpoly(rectangle,color->[0,0,0]);  drawtext(org+[0.5,0.5],"大きな数",size->28););//半角から全角へ han2zen(str):=(  han="+,-./0123456789:;<=>";  zen=["0B","0C","0D","0E","0F","10","11","12","13","14","15","16","17","18","19","1A","1B","1C","1D","1E"];  if(isreal(str),str=text(str));  ret="";  repeat(length(str),s,    char=str_s;    n=indexof(han,char);    if(n>0,ret=ret+unicode("FF"+zen_n),ret=ret+"");  );  ret;);// 入力用数字の表示Nochar=["０","１","２","３","４","５","６","７","８","９","１０"];Nochar=["０","１","２","３","４","５","６","７","８","９"];zen(n):=(  regional(str,m,ret);  str=text(n);  ret="";  repeat(length(str),    if(str_#==".",      ret=ret+Nochar_11;      ,      m=parse(str_#)+1;      ret=ret+Nochar_m;    );  );  ret;);//数字と文字が混在した文字列で数字のみ全角にするzenstr(str):=(  regional(s,t,ret);  ret="";  repeat(length(str),    s=str_#;    t=indexof("0123456789",s);    if(t>0,s=zen(t-1));    ret=ret+s;  );  ret;);dispno(bool):=(  if(bool,pos=apply(1..11,[6.2+2*#,-1.7]),pos=apply(1..11,[-40,0]));  forall(0..10,parse("Text"+#+".xy=pos_"+(#+1)));  drawimage(pos_11+[1,0.4],"erasem.png",scale->1.3););//////////////////////////////////////////////// 入力判定 正解を Seikai とする//dispmondai() 側で以下を実行//  if(Ansstr!="",drawtext(Anspos,Ansstr,size->42,color->Blue));//  if(Gotou,drawtext(Anspos,"？",size->42,color->Red));hantei():=(  seitou=text(Seikai);  ap=length(Ansstr)+1;  if(Ans>-1 & !Getseikai,    inputstr=text(Ans);    if(inputstr==seitou_ap,      Ansstr=Ansstr+inputstr;      Gotou=false;      ,      Gotou=true;      Gotoun=1;    );    if(Ansstr==seitou,      Getseikai=true;      Ansstep=Ansstep+1;    ); ); Ans=-1;);/////////////////////////// 入力判定　B,E タイプhantei():=(  if(Inputkey!="" & !Getseikai,    if(Inputkey=="B",      Inputstr=substring(Inputstr,0,length(Inputstr)-1);      Gotou=false;    );    if((Inputkey!="B") & (Inputkey!="E"),      Inputstr=Inputstr+Inputkey;      Errmsg="";  // 前のメッセージを消す    );    if(Inputkey=="E",        if(anscheck()==true,Getseikai=true;Anstype=s);//      repeat(Patternmax,s,//        if(Inputstr==Seikaistr_s,Getseikai=true;Anstype=s);//      );      if(Getseikai,        Getseikai=true;        Ansstep=Ansstep+1;        Gotou=false;        Errmsg="";        ,        Gotou=true;        Gotoun=1;			  gotoucheck();      );          );    Ansguide=false;  );  Inputkey="";);// 矩形を描く（drawpoly では線幅の指定ができないため)drawbox(xy,yoko,tate,haba,col):=drawbox(xy,yoko,tate,haba,col,0);drawbox(xy,yoko,tate,haba,col,dash):=(  connect([xy,xy+[yoko,0],xy+[yoko,tate],xy+[0,tate],xy],size->haba,color->col,dashtype->dash););// シャッフルshuffle(list,kai):=( regional(k,m,n,w);  n=length(list);  repeat(kai,    k=randomint(n)+1;    m=randomint(n)+1;    w=list_k;    list_k=list_m;    list_m=w;  ); list;);///////////////////////////////// 打ったキーの文字を数字にしてAnsに代入する　数字とBS,Enterが有効// Inputstr="" でBSキーを打ったときは Ans=-1 Enterなら Ans=-2numeric="0123456789";kk=keydownlist()_1;if(Kbinputenable,  if(48<=kk & kk<=57,    inputkey=numeric_(kk-47);    Inputstr=Inputstr+inputkey;  );  if(96<=kk & kk<=105,  // テンキー    inputkey=numeric_(kk-95);    Inputstr=Inputstr+inputkey;  );  if(kk==8,    if(length(Inputstr)>0,      Inputstr=substring(Inputstr,0,length(Inputstr)-1)      ,      Ans=-1;    );  );  if(kk==10,    if(Inputstr!="",       Ans=parse(Inputstr);Inputstr="",      Ans=-2;    );  ););// 打ったキーの文字を数字にしてInputkeyに代入する　数字と. ,BS,Enterが有効// BSキーを打ったときは B Enterなら E を返すnumeric="0123456789";kk=keydownlist()_1;if(48<=kk & kk<=57,  Inputkey=numeric_(kk-47););if(96<=kk & kk<=105,  // テンキー  Inputkey=numeric_(kk-95););if(kk==8,Inputkey="B");if(kk==10,Inputkey="E");if(kk==46 % kk==110,Inputkey=".");////////////////frac(pt,x,sz):=(  regional(pitch,str,p,s1,s2,snmax,snmin,add1,add2);  pitch=0.6;  if(x<0,   x=-x;   drawtext(pt,"-",size->sz);   pt=pt+[pitch,0];  );  str=text(x);  str=guess(x);  p=indexof(str,"/");  if(p>0,    s1=substring(str,0,p-1);    s2=substring(str,p,length(str));    snmax=max([length(s1),length(s2)]);    snmin=min([length(s1),length(s2)]);    add1=0;    add2=0;    if(length(s1)==snmax,add2=(snmax-snmin)/2*pitch);    if(length(s2)==snmax,add1=(snmax-snmin)/2*pitch);    drawtext(pt+[add2+0.2,-0.6],s2,size->sz); // 分母    drawtext(pt+[add1+0.2,+0.4],s1,size->sz);    draw([pt+[0,0.2],pt+[snmax*pitch+0.2,0.2]],color->[0,0,0],size->1.5);    ret=pt_1+snmax*pitch+0.4;    ,    drawtext(pt,x,size->sz);    ret=pt_1+length(text(x))*pitch;  );  [ret,pt_2];   // 戻り値);///// 花まるRed=[1,0,0];fx(t):=5*cos(t)-cos(5*t);fy(t):=5*sin(t)-sin(5*t);drawhana(center,radius):=(  hana=[];  repeat(72,t,    hana=append(hana,radius*1/4*[fx(pi/36*t),fy(pi/36*t)]);  );  drawpoly(hana,color->Red);//   fillpoly(hana,color->Red);  drawcircle(center,radius,color->Red);//  fillcircle(center,radius,color->Red); );//ptをorgまわりにth回転するrot(pt,org,th):=(  regional(z1,z2,z3);  z1=complex(org);  z2=complex(pt);  z3=z1+(z2-z1)*(cos(th)+i*sin(th));  gauss(z3););/////////////////////////////////////seiseki():=(  Text23.xy=[-20,1];  //ひんと  Text24.xy=[28,0];  //おわる  dispno(false);  drawtext([2,14],"せいせきです",size->24,color->Blue);  drawtext([22,14],"レベル"+zen(Level),size->24,color->Blue);  Text25.xy=[24,0];  if(length(Rireki)==Mondaimax,    Text25.xy=[-40,0];    drawtext([2,0],"これで ぜんぶです。",size->24,color->Blue);    if(length(select(Rireki,#_3==1))>0,      Text20.xy=[22,0];  // ふくしゅう      drawtext([2,-1.5],"「ふくしゅう」で，△のもんだいを やりなおせます。",size->24,color->Blue);      ,      drawimage([15,0],"yokudekita.png",scale->2);    );    ,    drawtext([2,0],"ちょっと きゅうけい しましょう。",size->24,color->Blue);  );  repeat(length(Rireki),s,    x=1+7*floor((s-1)/10);    y=12-mod(s-1,10);    drawtext([x,y],"("+s+")",size->20);    drawtext([x,y]+[2,0],Rireki_s_1+"-"+Rireki_s_2,size->22);    if(Rireki_s_3==0,mark="〇",mark="△");    drawtext([x,y]+[4.5,0],mark,size->22,color->Red);  ););retry():=(  Mondai=select(Rireki,#_3==1);  Retrymode=true;  Mondaimax=length(Mondai);  reset();  setting(););//カウンターを表示  k:0 前回まで, k:1 今回までdispcount():=(  n=length(Rireki);  repeat(n,s,    if(Rireki_s_3==0,mark="〇",mark="△");     drawtext([26+mod(s-1,5),14-floor((s-1)/5)],mark,size->24,color->Red);  ););// m,n の最大公約数を返すgcm(m,n):=( regional(yakusuu,gcm);  yakusu=select(1..m,mod(m,#)==0);  max(select(yakusu,mod(n,#)==0)););