 /*            MNR method 
                                                  mnrv1
												   2023.12.12
                                                   2023.12.27
remvalue(all);
*/

numer(f):=factor(num(ratsimp(f)))$
Numer(f):=numer(f)$
ratev(eq,rep):=ratsimp(ev(eq,rep))$
Ratev(eq,rep):=ratev(eq,rep)$

nthfactor(pol,kth):=block(
 [tmp,j,out],
 tmp:part(pol,0),
 if tmp="-" then
   tmp:part(pol,1)
 else
   tmp:pol
 ,
 j:length(tmp),
 print([numfactor,j]),
 if kth>j then kth:j,
 part(tmp,kth)
)$


angtan(m):=float(2*atan(m)*180/%pi)$
tanang(t):=float(tan(t/2*%pi/180))$

supAng(m):=ratsimp(1/m)$ /*hokaku*/
comAng(m):=ratsimp((1-m)/(m+1))$ /*yokaku*/
Hokaku(m):=ratsimp(1/m)$
Yokaku(m):=ratsimp((1-m)/(m+1))$
addAng(m1,m2):=ratsimp((m1+m2)/(1-m2*m1))$
dotProd(v1,v2):=
  ratsimp(v1[1]*v2[1]+v1[2]*v2[2])$
normsq(v):=
  ratsimp(v[1]^2+v[2]^2)$
crossProd(v1,v2):=
  ratsimp(v1[1]*v2[2]-v1[2]*v2[1])$ 

eqLine(pa1,pa2):=block(
  if pa1[1]=pa2[1] then
     _X=pa1[1]
  else
     _Y=pa1[2]+(pa2[2]-pa1[2])*(_X-pa1[1])/(pa2[1]-pa1[1])
)$

intsectLine(line1,line2):=block(
  [out],
  out:solve([line1,line2],[_X,_Y]),
  if length(out)>0 then
    out:ratsimp(ev([_X,_Y],out))
)$

intsectLinept(pts1,pts2):=block(
  [tmp1,tmp2,out],
  tmp1:eqLine(pts1[1],pts1[2]),
  tmp2:eqLine(pts2[1],pts2[2]),
  out:intsectLine(tmp1,tmp2),
  out
)$

/*
line1:eqLine([2,1],[4,3]);
line2:eqLine([a,b],[c,d]);
intsectLine(line1,line2);
*/

lenSeg2(p1,[p2]):=block(
 [tmp],
 if length(p2)>0 then
   tmp:(p2[1][1]-p1[1])^2+(p2[1][2]-p1[2])^2
 else
   tmp:(p1[1])^2+(p1[2])^2,
 ratsimp(tmp)
)$
lenSeg(p1,[p2]):=block(
 [tmp],
 if length(p2)>0 then
   tmp:lenSeg2(p1,p2)
 else
   tmp:lenSeg2(p1),
 ratsimp(sqrt(tmp))
)$
vect(A,B):=ratsimp(B-A)$
ptDirSeg(A,B,t):=ratsimp([A[1]+t*(B[1]-A[1]),A[2]+t*(B[2]-A[2])])$

/*---------------------*/

/*
assume(m>0,n>0,r>0,m^2+1>0,n^2+1>0,m*n-1<0)$
forget(...) 
*/

slide(v):=ratsimp(v+sliderVector)$
rotate(v):=block(
  [x,y,c,s,u],
  x:v[1]-rotCenter[1],
  y:v[2]-rotCenter[2],
  c:rotCS[1],
  s:rotCS[2],
  u:[c*x-s*y,s*x+c*y],
  ratsimp(u+rotCenter)
)$

putTriangle(m,n,r) := block(
  mAng:m,
  nAng:n,
  inR:r,
  assume(mAng>0,nAng>0,inR>0,mAng*nAng-1<0),
  edgeLeft:r*(1 + m^2)/(m*(1 - n*m)), edgL:edgeLeft,
  edgeRight:r*(1 + n^2)/(n*(1 - n*m)), edgR:edgeRight,
  edgeBottom:r*(m + n)/(n*m), edgB:edgeBottom,
  cirR:r*(m^2+1)*(n^2+1)/(4*m*n*(1-m*n)),
  exRa:r/(m*n),
  exRb:r*(m+n)/(m*(1-m*n)),
  exRc:r*(m+n)/(n*(1-m*n)),
  area:r^2*(m+n)/(m*n*(1-m*n)),
  halfPer:r*(m+n)/(m*n*(1-m*n)), half:halfPer,
  inCenter:[0,0], inC:inCenter,
  vertexLeft:[-r/m,-r], verL:vertexLeft,
  vertexRight:[r/n,-r], verR:vertexRight,
  vertexTop:[r*(n-m)/(1-m*n),r*(1+m*n)/(1-m*n)],
  verTop:vertexTop,
  cirCenter:[r*(m-n)/(2*m*n),
             r*(m^2+3*m^2*n^2+n^2-1)/(4*m*n*(1-m*n))],
  cirC:cirCenter,
  barCenter:[r*(2*m*n-1)*(n-m)/(3*m*n*(1-m*n)),
              r*(3*m*n-1)/(3*(1-m*n))],
  barC:barCenter,
  ortCenter:[r*(n-m)/(1-m*n),
             r*(3*m^2*n^2-m^2-2*m*n-n^2+1)/(2*m*n*(1-m*n))],
  ortC:ortCenter,
  exCentera:[r*(m-n)/(m*n),-r*(m*n+1)/(m*n)],
  exCa:exCentera,
  exCenterb:[-r*(1+m^2)/(m*(1-m*n)),r*n*(1+m^2)/(m*(1-m*n))],
  exCb:exCenterb,
  exCenterc:[r*(1+n^2)/(n*(1-m*n)),r*m*(1+n^2)/(n*(1-m*n))], 
  exCc:exCenterc,  
  sliderVector:[0,0],
  rotCenter:[0,0],
  rotCsSn:[1,0],
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$
putT(m,n,r):=putTriangle(m,n,r)$

putTriangle_btm(m,n,btm):=block(
  [r,ans],
  putTriangle(m,n,r),
  ans:ratsimp(solve(edgeBottom=btm,r)),
  putTriangle(m,n,ans),
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$

slideTriangle(A,B):=block(
  sliderVector:[B[1]-A[1],B[2]-A[2]],
  inCenter:slide(inCenter), inC:inCenter,
  vertexLeft:slide(vertexLeft), verL:vertexLeft,
  vertexRight:slide(vertexRight), verR:vertexRight,
  vertexTop:slide(vertexTop), verT:vertexTop,
  cirCenter:slide(cirCenter), cirC:cirCenter,
  barCenter:slide(barCenter), barC:barCenter,
  ortCenter:slide(ortCenter), ortC:ortCenter,
  exCentera:slide(exCentera), exCa:exCentera,
  exCenterb:slide(exCenterb), exCb:exCenterb,
  exCenterc:slide(exCenterc), exCc:exCenterc,
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$
slideT(A,B):=slideTriangle(A,B)$

rotateTriangle(tr,centre):=block(
  rotCenter:centre,
  rotCS:[(1-tr^2)/(1+tr^2),2*tr/(1 + tr^2)],
  inCenter:rotate(inCenter), inC:inCenter,
  vertexLeft:rotate(vertexLeft), verL:vertexLeft,
  vertexRight:rotate(vertexRight), verR:vertexRight,
  vertexTop:rotate(vertexTop), verT:vertexTop,
  cirCenter:rotate(barCenter), cirC:cirCenter,
  ortCenter:rotate(ortCenter), ortC:ortCenter,
  barCenter:rotate(barCenter), barC:barCenter,
  exCentera:rotate(exCentera), exCa:exCentera,
  exCenterb:rotate(exCenterb), exCb:exCenterb,
  exCenterc:rotate(exCenterc), exCc:exCenterc,
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$
rotateT(tr,centre):=rotateT(tr,centre)$

edgL:edgeLeft$
edgR:edgeRight$
edgB:edgeBottom$
half:halfPer$ 
inC:inCenter$
verL:vertexLeft$
verR:vertexRight$
verT:vertexTop$
cirC:cirCenter$
barC:barCenter$
ortC:ortCenter$
exCa:exCentera$ 
exCb:exCenterb$
exCc:exCenterc$
  
reduceDegree(pL,z,stp):=block(
  [dg1,dg2,co1,co2,tmp,tmp1,tmp2,ctr,out], 
  tmp1:expand(pL[1]), 
  tmp2:expand(pL[2]), 
  dg1:hipow(tmp1,z),
  dg2:hipow(tmp2,z), 
  print([dg1,dg2]),
  ctr:1, 
  while (0<dg2*dg1) and (ctr<stp) do block(
    co1:diff(tmp1,z,dg1)/factorial(dg1),
	co2:diff(tmp2,z,dg2)/factorial(dg2),
	tmp:gcd(co1,co2),
	co1:ratsimp(co1/tmp),
	co2:ratsimp(co2/tmp),
	if dg2<dg1 then block(
      tmp1:expand(co2*tmp1-co1*tmp2*z^(dg1-dg2)),
   	  dg1:hipow(tmp1,z)
    )else block(
	  tmp2:expand(co2*tmp1*z^(dg2-dg1)-co1*tmp2),
	  dg2:hipow(tmp2,z)
    ), 
	ctr:ctr + 1
  ),
  print([dg1,dg2]), 
  tmp:gcd(tmp1,tmp2),
  tmp1:factor(tmp1/tmp),
  tmp2:factor(tmp2/tmp),
  [tmp1,tmp2]
)$

/* inner cirle  */
inCircle(p1,p2,p3):=block(
  [a,b,c,S,s,tmp,out],
  a:normsq(p2-p3),
  b:normsq(p3-p1),
  c:normsq(p1-p2),
  a:ratsimp(sqrt(a)),
  b:ratsimp(sqrt(b)),
  c:ratsimp(sqrt(c)),
  s:(a+b+c)/2,
  S:sqrt(s*(s-a)*(s-b)*(s-c)),
  tmp:(a*p1+b*p2+c*p3)/(2*s),
  out:ratsimp([S/s,tmp]),
  out
)$

/* common tangent line */
commonTanLL(nL,C1,r1,C2,r2):=block(
  [mL,pA1,pB1,pC1,pA2,pB2,pC2,v1,v2,
   eq,sol,tmp,pts,out],
  putTriangle(mL,nL,r1),
  slideTriangle([0,0],C1),
  pA1:vertexTop,
  pB1:vertexLeft,
  pC1:vertexRight,
  putTriangle(mL,nL,r2), 
  slideTriangle([0,0],C2),
  pA2:vertexTop,
  pB2:vertexLeft,
  pC2:vertexRight,
  v1:ratsimp(pA1-pB1),
  v2:ratsimp(pA2-pB1),
  eq:crossProd(v1,v2),
  eq:num(ratsimp(eq)),
  eq:factor(eq/r^2),
  eq:nthfactor(eq,length(eq)),
  sol:solve(eq,mL),
  pA1:ratsimp(ev(pA1,sol)),
  pB1:ratsimp(ev(pB1,sol)),
  pC1:ratsimp(ev(pC1,sol)),
  pA2:ratsimp(ev(pA2,sol)),
  pB2:ratsimp(ev(pB2,sol)),
  pC2:ratsimp(ev(pC2,sol)),
  out:[sol,[pA1,pB1]],
  out
)$
commonTanRR(mR,C1,r1,C2,r2):=block(
   [nR,pA1,pC1,pA2,pC2,v1,v2,
    eq,sol,tmp,out],
  putTriangle(mR,nR,r1),
  slideTriangle([0, 0],C1),
  pA1:vertexTop,
  pB1:vertexLeft,
  pC1:vertexRight,
  putTriangle(mR,nR,r2),
  slideTriangle([0,0],C2),
  pA2:vertexTop,
  pB2:vertexLeft,
  pC2:vertexRight,
  v1:ratsimp(pA1-pC1),
  v2:ratsimp(pA2-pC1),
  eq:crossProd(v1,v2),
  eq:num(ratsimp(eq)),
  eq:factor(eq/r^2),
  sol:solve(eq,nR),
  pA1:ratsimp(ev(pA1,sol)),
  pB1:ratsimp(ev(pB1,sol)),
  pC1:ratsimp(ev(pC1,sol)),
  pA2:ratsimp(ev(pA2,sol)),
  pB2:ratsimp(ev(pB2,sol)),
  pC2:ratsimp(ev(pC2,sol)),
  out:[sol,[pA1,pC1]],
  out
)$